# マッチングアプリ プロジェクト構造解説（レベルアップ学習版）

## 📖 このドキュメントについて

このドキュメントは、プログラミング初心者から中級者まで段階的にレベルアップできるように、マッチングアプリのプロジェクト構造を詳しく解説し、実践的な学習ガイドを提供しています。

### 🎯 学習レベル別ガイド
- **🟢 初心者**: 基本概念と全体像の理解
- **🟡 中級者**: 実装詳細とベストプラクティス
- **🔴 上級者**: アーキテクチャ設計と最適化

## 🏗️ 全体構造

```
new_matching_app/
├── 📁 backend/             # サーバー側のプログラム（Nest.js + TypeScript）
├── 📁 ios/                 # iPhone/iPadアプリ（Swift + SwiftUI）
├── 📁 docs/                # 設計書・ドキュメント類
├── 📄 docker-compose.yml   # データベースなどの環境設定
├── 📄 README.md           # プロジェクト説明書
└── 📄 schema.prisma       # データベース設計書
```

## 🖥️ Backend（サーバー側）

### 基本情報
- **言語**: TypeScript（JavaScriptの進化版）
- **フレームワーク**: Nest.js（Node.jsベースのサーバーフレームワーク）
- **データベース**: PostgreSQL（高性能なデータベース）
- **ORM**: Prisma（データベースを簡単に扱うツール）

### ディレクトリ構造

```
backend/
├── 📁 src/                    # メインのソースコード
│   ├── 📁 controllers/        # API エンドポイント（ユーザーからのリクエストを受け取る）
│   │   ├── auth.controller.ts     # 認証関連（ログイン・登録）
│   │   ├── user.controller.ts     # ユーザー情報管理
│   │   ├── post.controller.ts     # 投稿・マッチング機能
│   │   ├── chat.controller.ts     # チャット機能
│   │   └── match.controller.ts    # マッチング処理
│   │
│   ├── 📁 services/           # ビジネスロジック（実際の処理を行う）
│   │   ├── auth.service.ts        # 認証処理
│   │   ├── user.service.ts        # ユーザー管理処理
│   │   ├── post.service.ts        # 投稿管理処理
│   │   ├── chat.service.ts        # チャット処理
│   │   └── prisma.service.ts      # データベース接続
│   │
│   ├── 📁 modules/            # 機能ごとのモジュール（関連する機能をまとめる）
│   │   ├── auth.module.ts         # 認証モジュール
│   │   ├── user.module.ts         # ユーザーモジュール
│   │   ├── post.module.ts         # 投稿モジュール
│   │   └── chat.module.ts         # チャットモジュール
│   │
│   ├── 📁 dto/                # データ転送オブジェクト（APIで送受信するデータの形式）
│   │   ├── auth.dto.ts            # 認証データ形式
│   │   ├── user.dto.ts            # ユーザーデータ形式
│   │   ├── post.dto.ts            # 投稿データ形式
│   │   └── chat.dto.ts            # チャットデータ形式
│   │
│   ├── 📁 guards/             # セキュリティ（認証チェック）
│   │   ├── jwt-auth.guard.ts      # JWT認証ガード
│   │   └── ws-jwt-auth.guard.ts   # WebSocket用認証ガード
│   │
│   ├── 📁 gateways/           # リアルタイム通信（WebSocket）
│   │   └── chat.gateway.ts        # チャット用リアルタイム通信
│   │
│   ├── 📁 config/             # 設定ファイル
│   │   ├── app.config.ts          # アプリケーション設定
│   │   ├── database.config.ts     # データベース設定
│   │   ├── jwt.config.ts          # JWT設定
│   │   └── rate-limit.config.ts   # アクセス制限設定
│   │
│   └── 📁 decorators/         # カスタムデコレータ（便利な機能）
│       └── user.decorator.ts      # ユーザー情報取得用
│
├── 📁 prisma/                 # データベース関連
│   ├── schema.prisma              # データベース設計書
│   ├── 📁 migrations/             # データベース変更履歴
│   └── seed.ts                    # 初期データ投入スクリプト
│
├── 📁 test/                   # テストコード
└── 📄 package.json            # プロジェクト設定・依存関係
```

### 主要な技術要素

#### 1. **Controllers（コントローラー）**
- **役割**: ユーザーからのHTTPリクエストを受け取り、適切なサービスに処理を委譲
- **例**: `POST /auth/login` でログイン処理を呼び出す

#### 2. **Services（サービス）**
- **役割**: 実際のビジネスロジックを実装
- **例**: パスワードの暗号化、データベースへの保存

#### 3. **DTOs（Data Transfer Objects）**
- **役割**: APIで送受信するデータの形式を定義
- **例**: ユーザー登録時に必要な情報（ニックネーム、年齢、性別など）

#### 4. **Guards（ガード）**
- **役割**: セキュリティチェック
- **例**: ログインしているユーザーのみアクセス可能にする

#### 5. **Prisma**
- **役割**: データベースとの通信を簡単にする
- **特徴**: SQLを書かずにTypeScriptでデータベース操作

## 📱 iOS App（アプリ側）

### 基本情報
- **言語**: Swift（Appleの開発言語）
- **UI フレームワーク**: SwiftUI（宣言的UI）
- **アーキテクチャ**: MVVM（Model-View-ViewModel）

### ディレクトリ構造

```
ios/MatchingApp/
├── 📄 MatchingAppApp.swift      # アプリのエントリーポイント
├── 📄 ContentView.swift         # メイン画面（認証状態管理）
├── 📄 Models.swift              # データモデル定義
│
├── 🔐 認証関連
│   ├── 📄 LoginView.swift           # ログイン画面
│   ├── 📄 RegistrationView.swift    # 新規登録画面
│   └── 📄 TokenStore.swift          # 認証トークン管理
│
├── 🏠 メイン機能
│   ├── 📄 HomeView.swift            # ホーム画面（投稿一覧）
│   ├── 📄 TabRootView.swift         # タブ画面
│   └── 📄 SettingsView.swift        # 設定画面
│
├── 💬 チャット機能
│   ├── 📄 ChatView.swift            # チャット画面
│   ├── 📄 ChatViewModel.swift       # チャット画面のロジック
│   ├── 📄 MessageBubbleView.swift   # メッセージ表示部品
│   ├── 📄 MessageInputView.swift    # メッセージ入力部品
│   └── 📄 ChatMessageEntity.swift   # チャットデータ保存
│
├── 🌐 通信・ユーティリティ
│   ├── 📄 APIClient.swift           # サーバーとの通信
│   ├── 📄 WebSocketManager.swift    # リアルタイム通信
│   ├── 📄 DeviceManager.swift       # デバイス情報管理
│   └── 📄 AppConfig.swift           # アプリ設定
│
└── 📁 Assets.xcassets           # 画像・アイコン類
```

### 主要な技術要素

#### 1. **SwiftUI Views**
- **役割**: ユーザーインターフェース（画面）の定義
- **特徴**: 宣言的（「どう見せるか」を記述）

#### 2. **ViewModels**
- **役割**: 画面のロジック（状態管理・データ処理）
- **例**: チャットメッセージの送受信処理

#### 3. **APIClient**
- **役割**: サーバーとの通信
- **機能**: HTTP リクエスト、認証ヘッダーの管理

#### 4. **WebSocketManager**
- **役割**: リアルタイム通信（チャット）
- **ライブラリ**: Socket.IO を使用

## 🗄️ データベース設計

### 主要テーブル

```
Users（ユーザー）
├── id: UUID（一意識別子）
├── nickname: 文字列（ニックネーム）
├── gender: 文字列（性別）
├── age: 数値（年齢）
├── prefecture: 文字列（都道府県）
└── 作成日時・更新日時

Posts（投稿）
├── id: UUID
├── userId: UUID（投稿者）
├── title: 文字列（タイトル）
├── content: 文字列（内容）
├── targetGender: 文字列（対象性別）
├── prefecture: 文字列（対象地域）
└── 作成日時・更新日時

Matches（マッチング）
├── id: UUID
├── postId: UUID（投稿）
├── applicantId: UUID（応募者）
├── status: 文字列（ステータス）
└── 作成日時・更新日時

ChatRooms（チャットルーム）
├── id: UUID
├── matchId: UUID（マッチング）
└── 作成日時・更新日時

Messages（メッセージ）
├── id: UUID
├── roomId: UUID（チャットルーム）
├── senderId: UUID（送信者）
├── content: 文字列（メッセージ内容）
└── 作成日時
```

## 🔄 データフロー

### 1. **ユーザー登録・ログイン**
```
iOS App → APIClient → Backend Controller → Service → Database
                                      ↓
iOS App ← APIClient ← Backend Controller ← Service ← Database
```

### 2. **投稿作成・取得**
```
iOS App → APIClient → Post Controller → Post Service → Database
                                                   ↓
iOS App ← APIClient ← Post Controller ← Post Service ← Database
```

### 3. **リアルタイムチャット**
```
iOS App → WebSocketManager → Chat Gateway → Chat Service → Database
                                                      ↓
iOS App ← WebSocketManager ← Chat Gateway ← Chat Service ← Database
```

## 🛠️ 開発・運用ツール

### **Docker**
- **役割**: データベース（PostgreSQL）の環境構築
- **メリット**: 誰でも同じ環境で開発可能

### **Prisma**
- **役割**: データベース管理
- **機能**:
  - マイグレーション（データベース構造の変更管理）
  - クエリビルダー（SQLを書かずにデータベース操作）

### **JWT（JSON Web Token）**
- **役割**: ユーザー認証
- **仕組み**: ログイン時にトークンを発行、以降のリクエストで認証

### **Socket.IO**
- **役割**: リアルタイム通信
- **用途**: チャット機能

## 🔧 セットアップから動作まで

### 1. **環境準備**
```bash
# Node.js, Docker のインストール
# プロジェクトクローン
git clone <repository>
cd new_matching_app
```

### 2. **バックエンド起動**
```bash
# データベース起動
docker-compose up -d

# 依存関係インストール
cd backend
npm install

# データベース設定
npm run prisma:migrate
npm run prisma:generate

# サーバー起動
npm run start:dev
```

### 3. **iOS アプリ起動**
```bash
# Xcode でプロジェクトを開く
open ios/MatchingApp.xcodeproj

# シミュレーターで実行
```

## 🎯 各コンポーネントの責任

### **Backend の責任**
- ユーザー認証・認可
- データの永続化（データベース）
- ビジネスロジックの実装
- API エンドポイントの提供
- リアルタイム通信の管理

### **iOS App の責任**
- ユーザーインターフェース
- ユーザー操作の処理
- サーバーとの通信
- ローカルデータの管理（一時的なもの）
- ユーザー体験の最適化

### **Database の責任**
- データの永続化
- データの整合性保証
- トランザクション管理
- パフォーマンス最適化

## 💡 学習のポイント

### **初心者の方へ**
1. **まずは全体像を把握**: 各フォルダが何をしているかを理解
2. **一つずつ詳しく**: 興味のある部分から深く学習
3. **実際に動かしてみる**: 実際にコードを変更して動作確認
4. **ログを見る**: エラーメッセージやログから学習

### **次のステップ**
1. **TypeScript**: JavaScript の型付き版
2. **Nest.js**: Node.js のフレームワーク
3. **Prisma**: データベース ORM
4. **SwiftUI**: iOS の UI フレームワーク
5. **Socket.IO**: リアルタイム通信

## 📚 参考資料

- [Nest.js 公式ドキュメント](https://nestjs.com/)
- [Prisma 公式ドキュメント](https://www.prisma.io/docs)
- [SwiftUI 公式ドキュメント](https://developer.apple.com/xcode/swiftui/)
- [Socket.IO 公式ドキュメント](https://socket.io/docs/)

---

## 🚀 実践学習セクション

### 🟢 初心者向け実習

#### 実習1: プロジェクト構造の理解
```bash
# プロジェクトの基本構造を確認
find . -maxdepth 2 -type d | grep -v node_modules | sort

# バックエンドの主要ファイルを確認
ls -la backend/src/
ls -la backend/src/controllers/
ls -la backend/src/services/

# iOSアプリの主要ファイルを確認
ls -la ios/MatchingApp/
```

**課題**: 上記コマンドを実行し、各ディレクトリの役割を説明してください。

#### 実習2: 簡単なAPIエンドポイントの理解
実際のコードを見てみましょう：

**Auth Controller (`backend/src/controllers/auth.controller.ts`)**
```typescript
@Controller('auth')
export class AuthController {
  @Post('register')
  async register(@Body() createUserDto: CreateUserDto): Promise<AuthResponseDto> {
    return this.authService.register(createUserDto, deviceId);
  }
}
```

**学習ポイント**:
- `@Controller('auth')`: このクラスが `/auth` のAPIを担当
- `@Post('register')`: POST `/auth/register` エンドポイント
- `@Body()`: リクエストボディからデータを取得
- `Promise<AuthResponseDto>`: 非同期処理でレスポンス形式を指定

**課題**: 他のコントローラーファイルを開いて、同様のパターンを見つけてください。

#### 実習3: データ型の理解 (DTO)
```typescript
export class CreateUserDto {
  @IsString()
  @IsNotEmpty()
  @Length(1, 20)
  nickname: string;

  @IsString()
  @IsNotEmpty()
  gender: 'male' | 'female';
}
```

**学習ポイント**:
- バリデーション装飾子(`@IsString()`, `@IsNotEmpty()`)
- 型安全性（TypeScript）
- データの制約（文字列長、許可値）

### 🟡 中級者向け実習

#### 実習4: 認証フローの深堀り
認証サービスの実装を詳しく見てみましょう：

```typescript
async register(createUserDto: CreateUserDto, deviceId: string): Promise<AuthResponseDto> {
  // 1. 既存デバイス確認
  const existingDeviceAuth = await this.prisma.deviceAuth.findUnique({
    where: { deviceId },
    include: { user: true },
  });

  // 2. ユーザー作成
  const user = await this.prisma.user.create({
    data: {
      nickname: createUserDto.nickname,
      gender: createUserDto.gender,
      age: parseInt(createUserDto.age, 10),
      prefecture: createUserDto.prefecture,
    },
  });

  // 3. JWT トークン生成
  const tokens = await this.generateTokens(user.id, deviceId);
}
```

**実装パターンの分析**:
1. **Guard Clauses**: 早期リターンパターン
2. **Transaction**: データの整合性保証
3. **Error Handling**: 適切な例外処理
4. **Security**: JWT トークンによる認証

**課題**:
1. なぜデバイスIDベースの認証を採用しているか考察してください
2. JWT トークンの生成ロジックを読み解いてください
3. セキュリティ上の考慮点を挙げてください

#### 実習5: SwiftUI + MVVM パターンの理解
```swift
struct HomeView: View {
    @State private var posts: [PostResponse] = []
    @State private var isLoading = false
    @State private var errorMessage: String?

    var body: some View {
        NavigationView {
            if isLoading {
                ProgressView("読み込み中...")
            } else if let errorMessage {
                Text("エラー: \(errorMessage)")
            } else {
                List(posts, id: \.id) { post in
                    // 投稿表示
                }
            }
        }
    }
}
```

**MVVM パターンの要素**:
- **Model**: `PostResponse` データ構造
- **View**: `HomeView` UI表示
- **ViewModel**: 状態管理 (`@State` プロパティ)

**学習ポイント**:
- 宣言的UI（どう表示するかを宣言）
- 状態駆動UI（状態が変わると自動でUI更新）
- 非同期処理の扱い

### 🔴 上級者向け実習

#### 実習6: アーキテクチャ設計の深堀り

**Clean Architecture の実装**:
```
Controller → Service → Repository (Prisma) → Database
     ↓         ↓           ↓              ↓
   HTTP    Business    Data Access    Persistence
   Layer     Logic       Layer         Layer
```

**実装例の分析**:
```typescript
// Controller: HTTPレイヤー
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}
}

// Service: ビジネスロジック
@Injectable()
export class AuthService {
  constructor(private readonly prisma: PrismaService) {}
}

// Repository: データアクセス (Prisma)
@Injectable()
export class PrismaService extends PrismaClient {}
```

**設計原則**:
1. **依存性注入**: 疎結合な設計
2. **単一責任原則**: 各層が明確な役割
3. **開放閉鎖原則**: 拡張可能、変更に閉じている

#### 実習7: データベース設計の最適化

**Prisma Schema の分析**:
```prisma
model User {
  id          String   @id @default(uuid()) @db.Uuid
  nickname    String   @db.VarChar(20)
  // Relations
  posts       Post[]
  sentMessages Message[] @relation("UserSentMessages")
  roomParticipants RoomParticipant[]
}

model Post {
  id       String @id @default(uuid()) @db.Uuid
  userId   String @db.Uuid
  user     User   @relation(fields: [userId], references: [id])
  // Indexes
  @@index([userId])
  @@index([createdAt])
}
```

**最適化ポイント**:
1. **インデックス設計**: 検索性能の向上
2. **正規化**: データ重複の排除
3. **リレーション設計**: 適切な外部キー制約

---

## 🔧 ハンズオン チュートリアル

### チュートリアル1: 新しいAPIエンドポイントの追加

**目標**: ユーザープロフィール更新機能を実装

**ステップ1: DTOの定義**
```typescript
// backend/src/dto/user.dto.ts
export class UpdateUserDto {
  @IsOptional()
  @IsString()
  @Length(1, 20)
  nickname?: string;

  @IsOptional()
  @IsString()
  prefecture?: string;
}
```

**ステップ2: サービスの実装**
```typescript
// backend/src/services/user.service.ts
async updateProfile(userId: string, updateData: UpdateUserDto): Promise<User> {
  return this.prisma.user.update({
    where: { id: userId },
    data: updateData,
  });
}
```

**ステップ3: コントローラーの実装**
```typescript
// backend/src/controllers/user.controller.ts
@Put('profile')
@UseGuards(JwtAuthGuard)
async updateProfile(
  @GetUser() user: User,
  @Body() updateUserDto: UpdateUserDto,
): Promise<User> {
  return this.userService.updateProfile(user.id, updateUserDto);
}
```

**課題**: 上記コードを実際に実装し、API テストを行ってください。

### チュートリアル2: SwiftUI新画面の追加

**目標**: プロフィール編集画面を作成

```swift
struct ProfileEditView: View {
    @State private var nickname: String = ""
    @State private var prefecture: String = ""
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        NavigationView {
            Form {
                Section("基本情報") {
                    TextField("ニックネーム", text: $nickname)
                    Picker("都道府県", selection: $prefecture) {
                        ForEach(prefectures, id: \.self) { prefecture in
                            Text(prefecture).tag(prefecture)
                        }
                    }
                }
            }
            .navigationTitle("プロフィール編集")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("保存") {
                        saveProfile()
                    }
                }
            }
        }
    }

    private func saveProfile() {
        // API呼び出し実装
    }
}
```

---

## 🐛 デバッグ・トラブルシューティング

### よくあるエラーと解決方法

#### Backend編

**1. Prisma接続エラー**
```bash
Error: P1001: Can't reach database server
```
**解決方法**:
```bash
# Docker コンテナの確認
docker-compose ps

# データベース再起動
docker-compose restart postgres

# 接続設定確認
cat backend/.env | grep DATABASE_URL
```

**2. JWT認証エラー**
```
UnauthorizedException: Unauthorized
```
**解決方法**:
```bash
# トークンの確認
curl -H "Authorization: Bearer <token>" http://localhost:3000/users/me

# JWT設定確認
cat backend/.env | grep JWT
```

**3. バリデーションエラー**
```
BadRequestException: Validation failed
```
**解決方法**:
- DTOの制約を確認
- リクエストデータの形式をチェック
- ログでエラー詳細を確認

#### iOS編

**1. API通信エラー**
```swift
Error: URLError(.notConnectedToInternet)
```
**解決方法**:
```swift
// ネットワーク設定確認
// Info.plist の App Transport Security 設定
// APIエンドポイントURL確認
```

**2. SwiftUI State更新エラー**
```
Publishing changes from background threads is not allowed
```
**解決方法**:
```swift
DispatchQueue.main.async {
    self.posts = newPosts
}
```

### パフォーマンス最適化

#### Database最適化
```sql
-- 頻繁に使用されるクエリのインデックス追加
CREATE INDEX idx_posts_user_created ON posts(user_id, created_at);

-- スロークエリの確認
EXPLAIN ANALYZE SELECT * FROM posts WHERE user_id = 'uuid';
```

#### API最適化
```typescript
// ページネーション実装
async getPosts(page: number = 1, limit: number = 10) {
  return this.prisma.post.findMany({
    skip: (page - 1) * limit,
    take: limit,
    include: { user: true },
    orderBy: { createdAt: 'desc' },
  });
}
```

---

## 📚 発展学習リソース

### 技術スタック別学習パス

#### **Nest.js 深堀り**
1. **基礎**: [Nest.js 公式ドキュメント](https://nestjs.com/)
2. **実践**: カスタムデコレータ、インターセプター、フィルターの実装
3. **応用**: マイクロサービス、GraphQL、WebSocket

#### **Prisma マスター**
1. **基礎**: スキーマ設計、マイグレーション
2. **実践**: 複雑なクエリ、関数、トリガー
3. **応用**: パフォーマンス最適化、分散DB

#### **SwiftUI 上級**
1. **基礎**: 宣言的UI、状態管理
2. **実践**: カスタムコンポーネント、アニメーション
3. **応用**: Core Data、Combine、非同期処理

### プロジェクト拡張アイデア

#### **機能拡張**
1. **通知システム**: Push通知、リアルタイム通知
2. **画像アップロード**: プロフィール画像、投稿画像
3. **位置情報機能**: 近くのユーザー検索
4. **フィルター機能**: 年齢、地域、趣味での絞り込み
5. **管理者機能**: ユーザー管理、コンテンツ管理

#### **技術的改善**
1. **テスト実装**: 単体テスト、統合テスト、E2Eテスト
2. **CI/CD**: 自動デプロイ、コード品質チェック
3. **監視**: ログ収集、メトリクス、アラート
4. **セキュリティ**: ペネトレーションテスト、脆弱性スキャン
5. **スケーラビリティ**: 負荷分散、キャッシュ、CDN

---

## 🎯 学習チェックリスト

### 🟢 初心者レベル
- [ ] プロジェクト全体構造の理解
- [ ] 各ディレクトリの役割説明
- [ ] 基本的なAPIエンドポイントの動作確認
- [ ] SwiftUIの基本概念理解
- [ ] データベースの基本操作

### 🟡 中級者レベル
- [ ] 認証フローの完全理解
- [ ] DTOとバリデーションの実装
- [ ] MVVMパターンの実装
- [ ] Prismaクエリの最適化
- [ ] エラーハンドリングの実装

### 🔴 上級者レベル
- [ ] Clean Architectureの実装
- [ ] 新機能の設計と実装
- [ ] パフォーマンス最適化
- [ ] セキュリティ強化
- [ ] テスト戦略の策定

---

このドキュメントを使って段階的にスキルアップし、実際のプロジェクトで即戦力となれる開発者を目指しましょう！