# マッチングアプリ システム設計書

## 1. システム全体アーキテクチャ

### 1.1 アーキテクチャ概要

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   iOS Client    │    │   EC2 Server    │    │   AWS Services  │
│   (Swift)       │◄──►│   (Nest.js)     │◄──►│                 │
│                 │    │                 │    │ - RDS (PostgreSQL)│
│ - UI/UX         │    │ - REST API      │    │   (画像含む全データ)│
│ - WebSocket     │    │ - WebSocket     │    │ - SNS (Push)    │
│ - Push通知      │    │ - 認証 (JWT)    │    │ - ALB (Load Balancer)│
│ - ローカル保存  │    │ - ビジネスロジック│    │ - CloudWatch (Monitoring)│
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 1.2 技術スタック

#### フロントエンド（iOS）
- **言語**: Swift 6.2 ✅
- **フレームワーク**: SwiftUI(UIkitは可能な限り使わない方針) ✅
- **アーキテクチャ**: MVVM + Swift Concurrency（@MainActor / Actor 分離） ✅
- **ネットワーク**: URLSession + async/await + Socket.io(WebSocket) ✅
- **ローカル保存**: SwiftData (iOS 18) ✅
- **画像処理**: PhotosPicker + Photos Framework
- **プッシュ通知**: UserNotifications Framework
- **課金管理**: RevenueCat SDK
- **並行処理**: Swift 6.1 Concurrency (Actor, @MainActor, async/await) ✅
- **テスト**: Swift Testing (Swift 6.1新機能) ✅

#### バックエンド
- **言語**: TypeScript ✅
- **フレームワーク**: Nest.js 11.1.6 ✅
- **ランタイム**: Node.js 24 LTS ✅
- **ORM**: Prisma 6.16.1 ✅
- **WebSocket**: Socket.io 4.8.1 ✅
- **認証**: JWT (自前実装) ✅
- **課金管理**: RevenueCat Webhook
- **サーバー**: EC2 (Ubuntu 24.04 LTS)
- **プロセス管理**: PM2

#### インフラ・サービス（AWS）
- **データベース**: Amazon RDS (PostgreSQL 17) - 画像含む全データ保存 ✅
- **プッシュ通知**: Amazon SNS + APNs
- **ロードバランサー**: Application Load Balancer
- **監視**: CloudWatch (ログ・メトリクス)
- **ストレージ**: EBS (EC2用)
- **ネットワーク**: VPC + セキュリティグループ

### 1.3 システム構成

#### 1.3.1 フロントエンド層
```
iOS App
├── Presentation Layer (SwiftUI Views) ✅
│   ├── TabView (メインナビゲーション + Tab Bar Minimize Behavior) ✅
│   │   ├── ホームタブ ✅
│   │   │   ├── 掲示板画面（プルリフレッシュ対応）
│   │   │   └── 投稿作成画面
│   │   ├── チャットタブ ✅
│   │   │   ├── チャット一覧画面
│   │   │   └── 個別チャット画面（自前実装UI） ✅
│   │   └── 設定タブ ✅
│   │       ├── プロフィール設定
│   │       ├── アプリ設定
│   │       └── ヘルプ・サポート
│   ├── 共通コンポーネント
│   │   ├── ローディング表示
│   │   ├── エラーメッセージ表示
│   │   ├── 空状態表示
│   │   └── チャットUIコンポーネント（自前実装） ✅
│   │       ├── MessageBubbleView ✅
│   │       ├── MessageInputView ✅
│   │       └── TypingIndicatorView
├── ViewModel Layer (MVVM + Swift 6.1 Concurrency) ✅
│   ├── PostListViewModel（プルリフレッシュ対応 + @MainActor）
│   ├── ChatViewModel（自前実装 + Actor分離） ✅
│   ├── SettingsViewModel（プロフィール管理含む + @MainActor）
│   └── ErrorHandlingViewModel（並行処理対応）
├── Service Layer (Actor分離) ✅
│   ├── APIService（リトライ機能付き + async/await） ✅
│   ├── WebSocketService（自前実装 + Actor分離） ✅
│   ├── ChatService（自前実装 + メッセージ管理）
│   ├── NotificationService（@MainActor）
│   └── ImageService（並行処理対応）
├── Data Layer ✅
│   ├── SwiftData (ローカル) ✅
│   ├── Network (API通信 + async/await) ✅
│   └── WebSocket (自前実装 + リアルタイム通信) ✅
└── Test Layer (Swift Testing) ✅
    ├── Unit Tests ✅
    ├── Integration Tests
    └── UI Tests ✅
```

#### 1.3.2 バックエンド層（EC2）
```
EC2 Server (Ubuntu 24.04 LTS)
├── Nest.js Application ✅
│   ├── Controllers ✅
│   │   ├── UsersController ✅
│   │   ├── PostsController ✅
│   │   ├── MatchesController
│   │   ├── ChatController（自前実装） ✅
│   │   └── NotificationsController
│   ├── Services ✅
│   │   ├── UserService ✅
│   │   ├── PostService ✅
│   │   ├── MatchService
│   │   ├── ChatService（自前実装）
│   │   ├── WebSocketService（自前実装）
│   │   ├── NotificationService
│   │   └── AuthService (JWT) ✅
│   ├── Prisma Schema ✅
│   │   ├── User ✅
│   │   ├── Post ✅
│   │   ├── Match ✅
│   │   ├── Message（自前実装） ✅
│   │   ├── ChatRoom（自前実装） ✅
│   │   └── Notification ✅
│   ├── WebSocket Gateway（自前実装）
│   │   ├── ChatGateway
│   │   ├── MessageHandler
│   │   └── ConnectionManager
│   └── Middleware ✅
│       ├── AuthMiddleware ✅
│       ├── ValidationMiddleware ✅
│       ├── RateLimitMiddleware ✅
│       └── WebSocketAuthMiddleware（自前実装）
├── Process Management
│   └── PM2 (Process Manager)
├── Web Server
│   └── Nginx (Reverse Proxy + WebSocket Proxy)
├── Monitoring
│   ├── CloudWatch Agent
│   └── Custom Logs
    └── Cron Jobs ✅
        ├── Data Cleanup（24時間容量管理） ✅
        └── Health Checks
```

### 1.4 データフロー

#### 1.4.1 ユーザー登録フロー
```
iOS App → ALB → EC2 (Nest.js) → 簡易認証 → RDS PostgreSQL
    ↓
ローカル保存 (SwiftData)
```

#### 1.4.2 マッチングフロー
```
1. 投稿作成: iOS → ALB → EC2 → POST /posts → RDS PostgreSQL
2. 投稿一覧: iOS → ALB → EC2 → GET /posts → RDS PostgreSQL
3. マッチ申請: iOS → ALB → EC2 → POST /match/apply → RDS PostgreSQL
4. マッチ承認: iOS → ALB → EC2 → PATCH /match/approve → RDS PostgreSQL
5. チャット開始: WebSocket接続確立 (ALB経由)
```

#### 1.4.3 チャットフロー（自前実装） ✅
```
1. WebSocket接続: iOS ↔ EC2 (自前実装WebSocket via ALB) ✅
2. メッセージ送信: iOS → WebSocket → RDS PostgreSQL (BYTEA型で画像保存) ✅
3. リアルタイム受信: EC2 (Nest.js) → WebSocket → iOS ✅
4. 写真送信: iOS → PhotosPicker → WebSocket → RDS PostgreSQL (Binary)
5. タイマー管理: フロントエンド（20分制限表示制御・20分経過時はUI非表示、DB削除なし） ✅
6. ローカル保存: SwiftData (オフライン対応) ✅
7. 接続管理: ConnectionManager (自前実装)
8. 既読機能: フラグ管理 (自前実装) ✅
9. レート制限: 1デバイスあたり100リクエスト/分で制限 ✅
```

### 1.5 セキュリティ設計

#### 1.5.1 認証・認可（簡素化） ✅
- **デバイスID認証**: デバイス固有ID + UUID生成 (自前実装) ✅
- **API認証**: 簡易トークン認証 (Nest.js Middleware) ✅
- **WebSocket認証**: デバイスID検証 (Socket.io Middleware)
- **レート制限**: IPアドレス + デバイスIDベース制限 (Nest.js Middleware) ✅

#### 1.5.2 インフラコスト保護（重要）
- **DDoS対策**: ALB + CloudFront による分散攻撃対策
- **レート制限**: 厳格なAPI呼び出し制限 (1IPあたり最大2デバイス、1デバイスあたり100リクエスト/分) ✅
- **リソース制限**: EC2/RDS のCPU・メモリ使用量監視（CloudWatch Alarms）
- **自動スケーリング制限**: 予期しないコスト増加防止（手動スケーリングのみ）
- **データ削除**: 24時間後自動削除 (EC2 Cron + RDS DELETE文) ✅
- **IP制限**: 同一IPからの接続制限 (1IPあたり最大2デバイス)
- **サーバーセキュリティ**: Ubuntu 24.04 LTS セキュリティパッチ適用
- **コスト監視**: CloudWatch Billing Alerts（月額予算超過時アラート）
- **リクエストサイズ制限**: 画像アップロード2MB以内、APIリクエスト1MB以内
- **タイムアウト設定**: API応答30秒、WebSocket接続60秒でタイムアウト

#### 1.5.3 エロコンテンツ対応
- **多段階同意**: 写真送信前の確認
- **通報機能**: ワンタップ通報 (SNS通知)
- **利用規約**: 明確なガイドライン
- **画像制限**: 2MB以内、JPEG/PNGのみ

### 1.6 パフォーマンス設計

#### 1.6.1 レスポンス時間
- **API応答**: < 1秒
- **WebSocket遅延**: < 500ms
- **画像アップロード**: < 3秒
- **画面遷移**: < 300ms
- **プルリフレッシュ**: < 2秒
- **ローディング表示**: 即座に表示（< 100ms）

#### 1.6.2 スケーラビリティ
- **同時ユーザー**: 10-50人 (EC2 t3.micro実用範囲)
- **可用性**: 99% (Multi-AZ構成)
- **データベース**: RDS（読み取りレプリカ任意）+ 手動スケーリング
- **画像配信**: API経由（Nest.js）で配信 (小規模向け最適化)
- **サーバー管理**: 手動スケーリング設定

### 1.7 運用・監視

#### 1.7.1 ログ・監視
- **アプリログ**: CloudWatch Logs (CloudWatch Agent)
- **APIログ**: Nest.js Logger + CloudWatch
- **サーバーログ**: Nginx + PM2 ログ
- **システムログ**: Ubuntu 24.04 LTS システムログ
- **パフォーマンス**: CloudWatch Metrics + Custom Metrics
- **アラート**: CloudWatch Alarms + SNS
- **ヘルスチェック**: EC2 ヘルスチェック

#### 1.7.2 デプロイメント
- **開発環境**: Docker Compose + LocalStack
- **ステージング**: EC2 (ステージング環境)
- **本番環境**: EC2 + RDS (本番環境)
- **CI/CD**: GitHub Actions + EC2 デプロイ
- **インフラ**: Terraform (IaC)
- **プロセス管理**: PM2 (プロセス管理)

### 1.8 制約・前提

#### 1.8.1 技術制約
- **AWS無料枠**: 12ヶ月間の制限内利用
- **個人開発**: 小規模構成 (t3.micro, db.t3.micro)
- **iOS優先**: Androidは後回し
- **サーバー管理**: EC2の運用・メンテナンスが必要
- **コスト最適化**: サーバー管理コストを考慮
- **画像保存**: RDS BYTEA型でシンプル化
- **同時接続制限**: 最大50ユーザー (t3.micro実用範囲)
- **IP制限**: 同一IP最大5デバイス接続

#### 1.8.2 ビジネス制約
- **20分制限**: チャット自動削除
- **匿名性**: 個人情報保護
- **エロ対応**: 法的リスク最小化

## 2. AWSインフラ詳細設計

### 2.1 VPC構成
```
VPC (10.0.0.0/16)
├── Public Subnet (10.0.1.0/24) - ALB, NAT Gateway
├── Private Subnet A (10.0.2.0/24) - EC2 (Web Server)
├── Private Subnet B (10.0.3.0/24) - EC2 (App Server)
└── Private Subnet C (10.0.4.0/24) - RDS PostgreSQL
```

### 2.2 セキュリティグループ
- **ALB-SG**: HTTP/HTTPS (80, 443) from 0.0.0.0/0
- **EC2-SG**: HTTP (3000) from ALB-SG, SSH (22) from Admin IP
- **RDS-SG**: PostgreSQL (5432) from EC2-SG
- **Admin-SG**: SSH (22) from Admin IP

### 2.3 データベース設計
- **エンジン**: PostgreSQL 17
- **インスタンス**: db.t3.micro
- **ストレージ**: 20GB GP2 (開発), 100GB GP3 (本番)
- **バックアップ**: 不要
- **暗号化**: 不要（データ流出リスクが低いため）
- **画像保存**: BYTEA型でバイナリデータ保存
- **自動削除**: 20分後expires_atカラムで自動削除

### 2.4 EC2構成
- **インスタンス**: t3.micro (1 vCPU, 1GB RAM)
- **OS**: Ubuntu 24.04 LTS
- **ストレージ**: EBS GP3 (20GB)
- **プロセス管理**: PM2
- **Webサーバー**: Nginx (Reverse Proxy)
- **ヘルスチェック**: /health エンドポイント
- **自動起動**: systemd サービス

## 3. データベース詳細設計

### 3.1 SwiftDataモデル設計

#### 3.1.1 SwiftDataモデル定義
```swift
import SwiftData
import Foundation

@Model
class User {
    var id: UUID
    var nickname: String
    var gender: String
    var age: Int
    var prefecture: String
    var createdAt: Date
    var updatedAt: Date
    
    init(nickname: String, gender: String, age: Int, prefecture: String) {
        self.id = UUID()
        self.nickname = nickname
        self.gender = gender
        self.age = age
        self.prefecture = prefecture
        self.createdAt = Date()
        self.updatedAt = Date()
    }
}

@Model
class Post {
    var id: UUID
    var userId: UUID
    var content: String
    var purposeTag: String
    var createdAt: Date
    var expiresAt: Date
    
    init(userId: UUID, content: String, purposeTag: String) {
        self.id = UUID()
        self.userId = userId
        self.content = content
        self.purposeTag = purposeTag
        self.createdAt = Date()
        self.expiresAt = Date().addingTimeInterval(3600) // 1時間後
    }
}

@Model
class Match {
    var id: UUID
    var postId: UUID
    var applicantId: UUID
    var status: String // "pending", "approved", "rejected"
    var createdAt: Date
    var expiresAt: Date
    
    init(postId: UUID, applicantId: UUID) {
        self.id = UUID()
        self.postId = postId
        self.applicantId = applicantId
        self.status = "pending"
        self.createdAt = Date()
        self.expiresAt = Date().addingTimeInterval(1200) // 20分後
    }
}

@Model
class Message {
    var id: UUID
    var matchId: UUID
    var senderId: UUID
    var content: String?
    var imageData: Data?
    var imageType: String?
    var imageSize: Int?
    var createdAt: Date
    var expiresAt: Date
    
    init(matchId: UUID, senderId: UUID, content: String? = nil, imageData: Data? = nil) {
        self.id = UUID()
        self.matchId = matchId
        self.senderId = senderId
        self.content = content
        self.imageData = imageData
        self.imageType = imageData != nil ? "jpeg" : nil
        self.imageSize = imageData?.count
        self.createdAt = Date()
        self.expiresAt = Date().addingTimeInterval(1200) // 20分後
    }
}

@Model
class Notification {
    var id: UUID
    var userId: UUID
    var type: String
    var title: String
    var body: String
    var data: Data? // JSON data
    var createdAt: Date
    var expiresAt: Date
    
    init(userId: UUID, type: String, title: String, body: String) {
        self.id = UUID()
        self.userId = userId
        self.type = type
        self.title = title
        self.body = body
        self.createdAt = Date()
        self.expiresAt = Date().addingTimeInterval(86400) // 24時間後
    }
}
```

#### 3.1.2 SwiftData設定
```swift
import SwiftData
import SwiftUI

@main
struct MatchingApp: App {
    let modelContainer: ModelContainer
    
    init() {
        do {
            modelContainer = try ModelContainer(for: User.self, Post.self, Match.self, Message.self, Notification.self)
        } catch {
            fatalError("Could not initialize ModelContainer")
        }
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(modelContainer)
    }
}
```

### 3.2 データベース設計概要

#### 3.2.1 エンティティ設計
- **User**: ユーザー情報（ニックネーム、性別、年齢、都道府県）
- **Post**: 投稿情報（内容、目的タグ）
- **Match**: マッチング情報（申請者、承認状態、有効期限）
- **Message**: メッセージ情報（テキスト、画像データ、有効期限）
- **Notification**: 通知情報（タイプ、タイトル、本文、有効期限）

#### 3.2.2 データベース設計方針
- **ORM**: Prisma使用
- **画像保存**: BYTEA型でバイナリデータ保存
- **自動削除**: 24時間後の期限切れデータ自動削除
- **インデックス**: パフォーマンス最適化のための適切なインデックス設定

### 3.3 データベース設計詳細

#### 3.3.1 テーブル構成
- **users**: ユーザー基本情報（ID、ニックネーム、性別、年齢、都道府県）
- **posts**: 投稿情報（ID、ユーザーID、内容、目的タグ、有効期限）
- **matches**: マッチング情報（ID、投稿ID、申請者ID、状態、有効期限）
- **messages**: メッセージ情報（ID、マッチID、送信者ID、内容、有効期限）
- **message_attachments**: 添付情報（ID、message_id、file_data(BYTEA)、file_name、file_size、mime_type、有効期限）
- **notifications**: 通知情報（ID、ユーザーID、タイプ、タイトル、本文、有効期限）

#### 3.3.2 設計方針
- **主キー**: UUID使用
- **外部キー**: 適切な参照整合性制約
- **画像保存**: BYTEA型でバイナリデータ保存
- **有効期限**: 全テーブルにexpires_atカラム
- **自動削除**: 期限切れデータの自動削除機能

#### 3.3.3 パフォーマンス最適化
- **インデックス**: 検索頻度の高いカラムにインデックス設定
- **クエリ最適化**: Prismaのクエリ最適化機能活用
- **接続プール**: データベース接続の効率化

### 3.4 実装方針

#### 3.4.1 バックエンド実装
- **認証**: 簡易トークン認証（デバイスID + 匿名認証）
- **データベース**: Prisma 6.16.1 ORM使用
- **定期処理**: EC2 Cron Job（1日1回）
- **プロセス管理**: PM2使用
- **レート制限**: IP + デバイスIDベース制限実装
- **データベース接続**: PostgreSQL 17 (ローカル開発環境)
- **マイグレーション**: Prisma Migrate使用（初回マイグレーション完了）

#### 3.4.2 フロントエンド実装
- **データ管理**: SwiftData使用
- **非同期処理**: Swift 6.1 Concurrency (async/await + Actor)
- **画像処理**: PhotosPicker使用
- **ネットワーク**: URLSession + 自前実装WebSocket
- **UI/UX**: TabView + Tab Bar Minimize Behavior + プルリフレッシュ + ローディング表示
- **チャットUI**: 自前実装（MessageBubbleView, MessageInputView等）
- **エラーハンドリング**: ユーザーフレンドリーなエラー表示
- **リトライ機能**: 通信失敗時の自動再試行（最大3回）
- **並行処理**: @MainActor, Actor分離による安全な並行処理
- **テスト**: Swift Testing フレームワーク使用
- **チャット機能**: 自前実装（WebSocket + メッセージ管理）

#### 3.4.3 セキュリティ実装
- **通信暗号化**: HTTPS（ALB + Nginx）
- **認証**: 匿名JWT（デバイスIDベース）
- **自動削除**: 24時間後のデータ自動削除
- **セキュリティヘッダー**: Strict-Transport-Security, X-Content-Type-Options, Referrer-Policy, X-Frame-Options
- **並行処理セキュリティ**: Swift 6.1 Actor分離によるデータ競合防止

## 4. 実装詳細設計

### 4.1 UI/UX実装詳細

#### 4.1.1 タブベースナビゲーション
- **TabView**: SwiftUIのTabViewを使用
- **タブ構成**: ホーム、チャット、設定の3タブ
- **アイコン**: SF Symbolsを使用
- **バッジ表示**: 未読メッセージ数の表示
- **Tab Bar Minimize Behavior**: iOS 18+の新機能でスクロール時のタブバー最小化

#### 4.1.2 プルリフレッシュ機能
- **実装方法**: SwiftUIのrefreshable修飾子を使用
- **対象画面**: 掲示板画面、チャット一覧画面
- **視覚的フィードバック**: プル時のインジケーター表示
- **データ更新**: 最新の投稿・メッセージを取得

#### 4.1.3 ローディング表示
- **共通コンポーネント**: LoadingViewの作成
- **表示タイミング**: データ取得中、画像アップロード中
- **アニメーション**: スピナーアニメーション
- **レスポンス時間**: 100ms以内で表示

#### 4.1.4 エラーハンドリング
- **エラー表示**: Alert、Toast、インライン表示
- **エラーメッセージ**: ユーザーフレンドリーな日本語メッセージ
- **リトライ機能**: 自動再試行（最大3回、指数バックオフ）
- **オフライン対応**: ネットワーク切断時の適切な表示

### 4.2 チャット機能自前実装詳細

#### 4.2.1 WebSocket実装（iOS側）
- **WebSocket接続**: URLSessionWebSocketTask使用
- **接続管理**: Actor分離による安全な接続管理
- **メッセージ送受信**: JSONエンコード/デコード処理

#### 4.2.2 チャットUI実装（SwiftUI）
- **メッセージバブル**: 自前実装のMessageBubbleView
- **入力フィールド**: 自前実装のMessageInputView
- **レイアウト**: 送信者別の左右配置、タイムスタンプ表示
- **タイマー表示**: 20分制限のカウントダウン表示

#### 4.2.3 バックエンドWebSocket実装（Nest.js）
- **WebSocket Gateway**: 自前実装のChatGateway
- **接続管理**: ConnectionManagerによる接続管理
- **メッセージ処理**: リアルタイム送信、既読機能

#### 4.2.4 Swift Testing実装
- **テストフレームワーク**: Swift Testing (Swift 6.1新機能)
- **テスト対象**: WebSocket接続、メッセージ管理

### 4.3 インフラコスト保護実装詳細

#### 4.3.1 コスト保護対策実装
- **レート制限**: Nest.js Middleware による厳格な制限実装
- **リソース監視**: CloudWatch Alarms による自動監視
- **接続制限**: WebSocket接続数の制限実装
- **リクエストサイズ制限**: 画像・APIリクエストのサイズ制限
- **タイムアウト設定**: 適切なタイムアウト値の設定
- **コストアラート**: 月額予算超過時の自動通知

### 4.4 自前実装のメリット・デメリット

#### 4.4.1 メリット
- **完全なカスタマイズ性**: 20分制限、匿名性など独自要件の実装が容易
- **コスト削減**: 月額料金なし、ライセンス料なし
- **データ制御**: 完全なデータ所有権とプライバシー保護
- **学習効果**: 技術スキルの向上と完全理解
- **保守性**: 自前実装による高い保守性

#### 4.4.2 デメリット
- **開発期間**: 3週間程度の開発期間が必要
- **技術的難易度**: WebSocket、暗号化などの技術知識が必要
- **メンテナンス**: 継続的なバグ修正と機能追加が必要
- **スケーラビリティ**: 大規模ユーザー対応時の制約

#### 4.4.3 推奨実装方針
- **段階的実装**: 基本機能から段階的に機能追加
- **テスト重視**: Swift Testingによる包括的なテスト
- **ドキュメント化**: 実装詳細の文書化
- **コードレビュー**: 品質確保のためのコードレビュー

### 4.5 広告実装詳細設計

#### 4.5.1 広告種類と配置

##### ネイティブ広告
- **掲示板内広告**: 投稿一覧に自然に混在する広告
  - 実装方法: 投稿データに広告フラグを追加
  - 表示頻度: 5投稿に1回の割合で表示
  - デザイン: 投稿カードと同様のデザインで統一感を保持

- **チャット間広告**: 横スクロールチャットの間に表示
  - 実装方法: チャット一覧に広告カードを挿入
  - 表示頻度: 3チャットに1回の割合で表示
  - デザイン: チャットカードと同様のデザイン

- **プロフィール画面広告**: 設定タブ内に配置
  - 実装方法: 設定項目の間に配置
  - 表示位置: プロフィール設定とアプリ設定の間
  - デザイン: 設定項目と同様のリスト形式

##### バナー広告
- **上部バナー**: 全タブの上部に固定表示
  - 実装方法: TabView内の各画面の上部に固定配置
  - サイズ: 320x50pt (標準バナーサイズ)
  - 表示条件: 常時表示（課金ユーザーは非表示）
  - 対象画面: ホームタブ、チャットタブ、設定タブ


##### インタースティシャル広告
- **画面遷移時**: タブ切り替え時に表示
  - 表示頻度: 3回に1回の割合
  - 表示タイミング: タブ切り替え完了後
  - スキップ可能: 3秒後にスキップ可能

- **アプリ起動時**: 初回起動後の表示
  - 表示頻度: 毎回表示（初回のみ）
  - 表示タイミング: アプリ起動完了後

##### リワード動画広告
- **マッチング回数増加**: リワード視聴で5回増加
  - 初期付与: 5回
  - 増加量: 1回視聴で5回増加
  - 上限: なし（無制限まで可能）

#### 4.5.2 広告実装技術仕様

##### 使用SDK
- **Google AdMob**: メイン広告SDK
- **Unity Ads**: リワード動画広告
- **Facebook Audience Network**: バックアップ広告

##### 実装技術
- **ネイティブ広告**: 投稿カードと同様のデザインで統一
- **リワード広告**: Actor分離による安全な管理
- **広告表示制御**: 課金状態に応じた表示/非表示

#### 4.5.3 広告表示ロジック

##### 表示条件
- **課金ユーザー**: 全広告非表示
- **無料ユーザー**: 全広告表示
- **リワード広告**: 条件満たした時のみ表示

##### 表示頻度制御
- **ネイティブ広告**: 5投稿/3チャットに1回
- **バナー広告**: 常時表示
- **インタースティシャル**: 3回に1回
- **リワード動画**: 条件満たした時のみ

### 4.6 課金プラン設計

#### 4.6.1 サブスクリプションプラン

##### プラン構成
- **週間プラン**: 980円/週（自動更新）
- **月間プラン**: 2980円/月（自動更新）
- **機能**: 無制限マッチング + 広告非表示
- **エンタイトルメント**: RevenueCat Entitlementsで機能制御

##### 価格設定根拠
- **週間プラン**: 月額換算約4,200円（月間プランより高め）
- **月間プラン**: 週間プランの約3倍（お得感を演出）
- **市場価格**: 他社マッチングアプリの価格帯を参考
- **現地通貨**: RevenueCatによる自動現地通貨対応

#### 4.6.2 課金機能実装

##### RevenueCat実装
- **商品管理**: RevenueCat Dashboardで商品設定
- **購入処理**: RevenueCat SDKによる簡易実装
- **状態管理**: RevenueCatによる自動的な課金状態管理
- **分析機能**: 収益分析、チャーン分析、LTV計算
- **クロスプラットフォーム**: iOS/Android対応
- **Webhook**: サーバー側での課金状態同期
- **エラーハンドリング**: RevenueCatによる自動リトライ機能

#### 4.6.3 課金UI実装

##### サブスクリプション画面
- **プラン選択UI**: 週間・月間プランの選択カード
- **購入フロー**: RevenueCat SDKによる簡易購入処理
- **利用規約**: 法的要件の表示
- **価格表示**: RevenueCatから取得した現地通貨価格

#### 4.6.4 課金状態管理

##### ユーザー状態管理
- **課金状態**: RevenueCat CustomerInfoによる自動管理
- **マッチング制限**: 無料ユーザーは回数制限、課金ユーザーは無制限
- **リワード機能**: 広告視聴による回数増加
- **エンタイトルメント**: RevenueCat Entitlementsによる機能制御
- **Webhook同期**: サーバー側での課金状態リアルタイム同期
- **オフライン対応**: ローカルキャッシュによる課金状態保持

### 4.7 次の設計項目

1. **API設計**: エンドポイント詳細仕様
2. **ワイヤーフレーム**: 画面遷移図、UI詳細設計
3. **セキュリティ設計**: 詳細なセキュリティ対策
4. **インフラ設計**: Terraformコード、デプロイ手順
5. **運用設計**: 監視・ログ・バックアップ戦略

---

*この設計書は要件定義書に基づいて作成され、SwiftData + async/await + Prisma 6.16.1 + Node.js 24 LTS + Nest.js 11.1.6 + JWT認証 + EC2 + RDS PostgreSQL 17 + BYTEA型での画像保存による完全サーバー管理のAWS+Nest.js構成を提案しています。*
