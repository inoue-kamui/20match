# コーディング規約（AI駆動開発用）

## 1. 目的・スコープ
- CursorによるAI駆動開発で一貫性のある高品質なコードを生成するための規約
- 対象: Swift 6.1 (iOS), TypeScript (Nest.js 11.1.6), Prisma 6.16.1, PostgreSQL 17
- 設計書との整合性を保ち、保守性・可読性・パフォーマンスを重視

## 2. アーキテクチャパターン（最重要）

### 2.1 アーキテクチャ遵守の原則
- **必須**: 設計書で定義されたアーキテクチャパターンを厳格に遵守
- **レイヤー分離**: 各レイヤーの責任を明確に分離し、横断的な依存を禁止
- **依存関係**: 上位レイヤーは下位レイヤーにのみ依存（依存性逆転の原則）
- **単一責任**: 各クラス・モジュールは単一の責任のみを持つ

### 2.2 iOS (Swift 6.1) アーキテクチャ
```
Presentation Layer (SwiftUI Views)
├── ViewModels (@MainActor) - UI状態管理のみ
├── Services (Actor分離) - ビジネスロジック・データアクセス
└── Models (SwiftData) - データ永続化
```

**厳格なルール**:
- **View**: UI表示のみ。ビジネスロジック禁止
- **ViewModel**: UI状態管理のみ。`@MainActor`必須
- **Service**: ビジネスロジック。Actor分離でデータ競合防止
- **Model**: データ構造定義。SwiftDataで永続化

### 2.3 Backend (Nest.js 11.1.6) アーキテクチャ
```
Controllers (HTTP/WebSocket)
├── Services (ビジネスロジック)
├── Repositories (データアクセス)
└── Entities (Prisma Models)
```

**厳格なルール**:
- **Controller**: HTTPリクエスト処理のみ。ビジネスロジック禁止
- **Service**: ビジネスロジック。他のServiceを呼び出し可能
- **Repository**: データアクセス。Prismaクライアント使用
- **Entity**: データ構造。Prismaスキーマで定義

### 2.4 アーキテクチャ違反の禁止事項
- **❌ 禁止**: Viewから直接Serviceを呼び出し
- **❌ 禁止**: Controllerでビジネスロジック実装
- **❌ 禁止**: Service間の循環依存
- **❌ 禁止**: レイヤーを跨いだ直接アクセス

### 2.5 ハードコーディング禁止（最重要）
- **絶対禁止**: 設定値、URL、APIキー、パスワードのハードコーディング
- **必須**: 全ての設定値は環境変数または設定ファイルで管理
- **セキュリティ**: 機密情報は環境変数のみで管理

## 3. 全般ルール

### 3.1 命名規則
- **ファイル名**: kebab-case
- **クラス/構造体**: PascalCase
- **関数/メソッド**: camelCase
- **定数**: SCREAMING_SNAKE_CASE
- **プライベート変数**: アンダースコアプレフィックス

### 3.2 コメント規則
- **必須コメント**: 複雑なビジネスロジック、20分制限処理、画像処理、WebSocket接続管理
- **アーキテクチャコメント**: レイヤー間の依存関係、責任分界点を明記
- **禁止**: 自明なコードのコメント

### 3.3 エラーハンドリング
- **必須**: 全ての非同期処理でエラーハンドリング

## 4. Swift 6.1 固有ルール

### 4.1 アーキテクチャパターン厳守（最重要）
- **MVVM + Actor分離**: 設計書で定義されたアーキテクチャを厳格に遵守
- **レイヤー責任**: 各レイヤーの責任を明確に分離し、横断的な依存を禁止
- **依存性注入**: Service層の依存関係を適切に管理

### 4.2 並行処理（Concurrency）
- **必須**: `@MainActor` でUI更新を保証
- **Actor分離**: データ競合を防ぐため、共有状態はActorで管理

### 4.3 SwiftUI パターン
- **View分離**: 1つのViewは単一責任
- **状態管理**: `@StateObject`, `@Published`, `@Binding` を適切に使い分け

### 4.4 SwiftData パターン
- **モデル定義**: `@Model` でデータ永続化
- **クエリ**: `@Query` でリアクティブなデータ取得

### 4.5 禁止パターン
- **UIKit混在**: 可能な限りSwiftUIのみ使用
- **強制アンラップ**: `!` の使用を避け、`if let` や `guard let` を使用
- **同期処理**: メインスレッドでの重い処理を避ける

## 5. TypeScript (Nest.js 11.1.6) 固有ルール

### 5.1 アーキテクチャパターン厳守（最重要）
- **レイヤードアーキテクチャ**: Controller → Service → Repository → Entity の順序で依存
- **依存性注入**: Nest.js 11.1.6のDIコンテナを活用した適切な依存関係管理
- **単一責任**: 各レイヤーは明確に定義された責任のみを持つ

### 5.2 エラーハンドリング
- **カスタム例外**: ビジネスロジック用の例外クラスを作成
- **HTTP例外**: Nest.jsの`HttpException`を使用

### 5.3 バリデーション
- **DTO**: 全てのAPIエンドポイントでDTOを使用
- **デコレータ**: `@IsString`, `@IsOptional`, `@Length` 等を使用

### 5.4 禁止パターン
- **any型**: 型安全性を保つため使用禁止
- **同期処理**: 非同期処理を適切に使用
- **直接DB操作**: Prisma 6.16.1クライアントを通さずにDBに直接アクセス

## 6. データベース関連ルール

### 6.1 Prisma 6.16.1使用
- **クエリ**: Prisma 6.16.1クライアントを使用（生SQLは最小限）
- **トランザクション**: 複数操作は`$transaction`で包む

### 6.2 マイグレーション
- **命名**: `YYYYMMDD_HHMMSS_description` 形式
- **ロールバック**: 必ずロールバック可能なマイグレーションを作成

## 7. WebSocket関連ルール

### 7.1 イベント命名
- **形式**: camelCase
- **一貫性**: クライアント・サーバー間で同じイベント名を使用

### 7.2 接続管理
- **認証**: 接続時にJWT検証を必須
- **エラーハンドリング**: 接続エラー時の適切な処理
- **Socket.io 4.8.1**: 最新のSocket.io機能を活用

## 8. セキュリティルール

### 8.1 認証・認可
- **JWT検証**: 全APIエンドポイントでJWT検証
- **権限チェック**: ルーム参加権限の確認

### 8.2 入力検証
- **サニタイゼーション**: ユーザー入力の適切な検証
- **ファイルアップロード**: ファイルサイズ・形式の制限

## 9. パフォーマンスルール

### 9.1 データベース
- **N+1問題**: Prismaの`include`で関連データを一括取得
- **インデックス**: 検索頻度の高いカラムにインデックス設定

### 9.2 メモリ管理
- **画像処理**: 適切なリサイズ・圧縮
- **キャッシュ**: 頻繁にアクセスされるデータのキャッシュ

## 10. テストルール

### 10.1 単体テスト（必須）
- **実装ルール**: 一機能実装したら必ず単体テストを作成・実行
- **カバレッジ**: 最低80%のコードカバレッジ
- **モック**: 外部依存はモックを使用
- **実行タイミング**: 機能実装完了後、即座にテスト作成・実行
- **品質保証**: テストが通らない場合は機能実装を修正

### 10.2 統合テスト
- **データベース**: テスト用DBを使用
- **WebSocket**: 実際の接続をテスト

## 11. ドキュメントルール

### 11.1 コード内ドキュメント
- **関数**: 複雑な関数にはJSDoc/ドキュメントコメント

### 11.2 README更新
- **新機能**: 新機能追加時はREADMEを更新
- **API変更**: API変更時はAPI定義書を更新

## 12. Git規則

### 12.1 コミットメッセージ
- **形式**: `type(scope): description`

### 12.2 ブランチ命名
- **形式**: `feature/description` または `fix/description`

## 13. 禁止事項

### 13.1 絶対禁止
- **ハードコーディング**: 設定値は環境変数または設定ファイル
- **デバッグコード**: 本番環境にデバッグコードを残す
- **パスワード**: コードにパスワードやAPIキーを直接記述
- **機密情報**: 環境変数以外での機密情報管理

### 13.2 環境変数管理規則
- **必須環境変数**: API_BASE_URL, WEBSOCKET_URL, DATABASE_URL, JWT_SECRET等
- **設定ファイル**: iOS用Config.plist、Backend用.env.example
- **環境別設定**: 開発/ステージング/本番で分離
- **セキュリティ**: 機密情報は環境変数のみ、本番ではデフォルト値禁止
- **バリデーション**: 起動時に必須環境変数の存在確認

### 13.3 推奨しない
- **長い関数**: 1つの関数は50行以内
- **深いネスト**: ネストは3レベル以内
- **魔法数値**: 定数として定義

## 14. AI開発時の注意点

### 14.1 アーキテクチャ重視のプロンプト設計
- **アーキテクチャ明記**: 必ずレイヤー構造と責任分界を明記
- **具体的**: 曖昧な指示ではなく、具体的な要件を記述
- **文脈**: 関連する設計書や既存コードの文脈を含める

### 14.2 アーキテクチャチェックリスト
AI生成コードのレビュー時に以下を必ず確認:
- **レイヤー分離**: 各レイヤーの責任が適切に分離されているか
- **依存関係**: 上位レイヤーは下位レイヤーのみに依存しているか
- **単一責任**: 各クラス・モジュールは単一の責任のみを持っているか
- **循環依存**: Service間の循環依存がないか
- **データフロー**: データの流れが設計書通りか
- **ハードコーディング**: 設定値が環境変数で管理されているか
- **セキュリティ**: 機密情報が適切に環境変数で管理されているか
- **テスト実装**: 機能実装後に単体テストが作成・実行されているか

### 14.3 コードレビュー
- **AI生成コード**: 必ず人間がレビュー
- **アーキテクチャ遵守**: 上記チェックリストでアーキテクチャを確認
- **設計書整合性**: 設計書との整合性を確認
- **セキュリティ**: セキュリティ要件の遵守を確認
- **テスト実行**: 機能実装後は必ず単体テストを作成・実行して確認

---

*この規約は、マッチングアプリの開発において、AI駆動開発の品質と効率を最大化することを目的としています。*
