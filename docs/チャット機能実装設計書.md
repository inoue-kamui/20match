# チャット機能実装設計書

## 1. 概要

### 1.1 目的
マッチングアプリにおけるリアルタイムチャット機能を自前実装で開発する。2025年9月14日時点の最新技術を活用し、高いパフォーマンス、セキュリティ、スケーラビリティを実現する。

### 1.2 基本要件
- **20分制限機能**: マッチ成立から20分後にチャット非表示（切迫感演出）
- **リアルタイム通信**: WebSocketによる即座なメッセージ送受信
- **画像送信**: 写真の送信・受信機能（最大2MB、JPEG/PNG）
- **既読機能**: メッセージの既読状態管理
- **オフライン対応**: ネットワーク切断時の適切な処理
- **広告表示**: チャット内バナー広告の表示

### 1.3 技術要件
- **フロントエンド**: Swift 6.1 + SwiftUI + Swift 6.1 Concurrency
- **バックエンド**: Nest.js 11.1.6 + Socket.io 4.8.1 (最新安定版) + Node.js 24 LTS
- **データベース**: PostgreSQL 17 (RDS) + BYTEA型画像保存
- **リアルタイム通信**: WebSocket + Socket.io
- **課金管理**: RevenueCat SDK

## 2. システム構成

### 2.1 全体アーキテクチャ
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   iOS Client    │    │   EC2 Server    │    │   RDS PostgreSQL│
│                 │    │                 │    │                 │
│ - SwiftUI       │◄──►│ - Nest.js 11.1.6│◄──►│ - PostgreSQL 17 │
│ - WebSocket     │    │ - Socket.io 4.8.1│    │ - BYTEA型保存   │
│ - SwiftData     │    │ - JWT認証       │    │ - 自動削除      │
│ - RevenueCat    │    │ - 広告管理      │    │ - インデックス  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 2.2 データフロー
```
1. アプリ起動 → WebSocket接続確立（Socket.io 4.8.1）
2. マッチング申請 → リアルタイム通知（フォアグラウンド時）
3. マッチ成立 → チャットルーム作成 → ルーム参加
4. メッセージ送信 → PostgreSQL 17保存（Nest.js経由） → リアルタイム配信
5. 画像送信 → BYTEA型保存 → 配信
6. 20分経過 → サービス機能（UI上でチャット非表示）→ 切迫感演出
7. 24時間経過 → 容量管理削除処理（Cron Job）→ 古いデータ削除
8. 接続切断 → 自動再接続（指数バックオフ）
9. 広告表示 → RevenueCat課金状態確認 → 条件付き表示
10. アプリ終了 → WebSocket接続切断

バックグラウンド時通知戦略:
- フォアグラウンド: WebSocket + インアプリ通知
- バックグラウンド: APNs プッシュ通知
- アクティブ復帰: WebSocket再接続 + 未読メッセージ同期
```

### 2.3 技術スタック詳細

#### フロントエンド（iOS）
- **Swift 6.1**: 最新の並行処理機能（Actor、async/await）
- **SwiftUI**: 宣言的UI、TabView + Tab Bar Minimize Behavior
- **SwiftData**: ローカルデータ永続化（iOS 18）
- **Socket.io Client**: WebSocket通信
- **UserNotifications Framework**: プッシュ通知（APNs）
- **RevenueCat SDK**: 課金管理
- **PhotosPicker**: 画像選択・送信

#### バックエンド（Nest.js）
- **Nest.js 11.1.6**: 依存性注入、デコレータ
- **Socket.io 4.8.1**: リアルタイム通信、自動再接続（最新安定版）
- **Node.js 24 LTS**: 最新のV8エンジン、パフォーマンス向上
- **Prisma**: 型安全なORM
- **JWT**: 認証・認可
- **Amazon SNS**: プッシュ通知配信（APNs）
- **Cron Jobs**: 定期データ削除（24時間容量管理）

#### データベース（PostgreSQL 17）
- **PostgreSQL 17**: 最新のパフォーマンス最適化
- **BYTEA型**: バイナリデータ（画像）保存
- **自動削除**: 期限切れデータの自動削除（24時間容量管理）
- **インデックス最適化**: 検索パフォーマンス向上
- **接続プール**: 効率的な接続管理

## 3. データベース設計

### 3.1 テーブル構成

#### 3.1.1 基本テーブル設計
- **users**: ユーザー管理
- **chat_rooms**: チャットルーム管理
- **room_participants**: ルーム参加者管理
- **messages**: メッセージ保存（基本構造のみ）
- **message_attachments**: 画像・ファイル管理（BYTEA方式）
- **ad_banners**: 広告バナー管理
- **user_subscriptions**: RevenueCat課金状態管理

#### 3.1.2 主要テーブル仕様

##### users テーブル
- **主キー**: UUID（gen_random_uuid()）
- **基本情報**: nickname, gender, age, prefecture, created_at, updated_at
- **インデックス**: nickname, gender, age, prefecture（検索最適化）

##### chat_rooms テーブル
- **主キー**: UUID（gen_random_uuid()）
- **外部キー**: match_id（マッチングアプリ特有）
- **サービス機能**: created_at（20分制限計算用）
- **容量管理**: 24時間前のデータを1日1回削除
- **インデックス**: created_at（20分制限用・容量管理用）

##### room_participants テーブル
- **主キー**: UUID（gen_random_uuid()）
- **外部キー**: room_id, user_id
- **制約**: ユニーク制約（room_id, user_id）
- **自動削除**: 24時間前のデータを1日1回削除
- **インデックス**: room_id, user_id（検索最適化）、created_at（容量管理用）

##### messages テーブル
- **主キー**: UUID（gen_random_uuid()）
- **外部キー**: room_id, sender_id
- **基本構造**: content, message_type, created_at
- **容量管理**: 24時間前のデータを1日1回削除
- **インデックス**: room_id, created_at（検索最適化）、created_at（容量管理用）

##### message_attachments テーブル
- **主キー**: UUID（gen_random_uuid()）
- **外部キー**: message_id
- **画像保存**: BYTEA型（PostgreSQL 17最適化）
- **メタデータ**: file_name, file_size, mime_type
- **制約**: 2MB以内、JPEG/PNGのみ
- **自動削除**: 24時間前のデータを1日1回削除
- **インデックス**: message_id（検索最適化）、created_at（容量管理用）


##### ad_banners テーブル
- **主キー**: UUID（gen_random_uuid()）
- **用途**: 広告バナー管理
- **制約**: 30日制限（expires_at）
- **インデックス**: is_active, expires_at, priority

### 3.2 インデックス設計

#### パフォーマンス最適化インデックス
- **users**: nickname, gender, age, prefecture（ユーザー検索）
- **chat_rooms**: created_at（20分制限用・24時間削除）
- **room_participants**: room_id, user_id（参加者検索）、created_at（24時間削除）
- **messages**: room_id, created_at（メッセージ検索）、created_at（24時間削除）
- **message_attachments**: message_id（添付ファイル検索）、created_at（24時間削除）
- **ad_banners**: is_active, expires_at, priority（広告表示）

#### PostgreSQL 17最適化
- **部分インデックス**: アクティブデータのみインデックス
- **複合インデックス**: 複数条件検索の最適化
- **BRINインデックス**: 時系列データの効率的なインデックス

### 3.3 データ型最適化

#### BYTEA型画像保存（message_attachments）
- **PostgreSQL 17**: バイナリデータ保存の最適化
- **圧縮**: クライアント側でJPEG圧縮（品質0.8）
- **サイズ制限**: 2MB以内
- **メタデータ分離**: ファイル情報は別カラムで管理

#### 標準的なテーブル設計
- **正規化**: テーブル間の適切な関係性
- **外部キー制約**: データ整合性の保証
- **インデックス最適化**: 検索パフォーマンス向上
- **制約**: データの有効性保証

#### 時系列データ最適化
- **パーティショニング**: 月単位でのテーブル分割
- **自動削除**: 期限切れデータの自動削除
- **アーカイブ**: 古いデータのアーカイブ処理

### 3.4 データ管理設計

#### 3.4.1 20分制限機能（サービス機能）
- **目的**: 切迫感演出によるユーザーエンゲージメント向上
- **実装方法**: UI上での表示制御（DB削除なし）
- **制御フィールド**: created_at（chat_roomsテーブル）
- **表示ロジック**: 現在時刻 > (created_at + 20分) の場合、チャット非表示
- **計算式**: 制限時間 = created_at + 20分
- **タイマー表示**: リアルタイムで残り時間をカウントダウン表示

#### 3.4.2 24時間削除（容量管理）
- **目的**: データベース容量管理
- **削除対象テーブル**: chat_rooms, room_participants, messages, message_attachments
- **削除条件**: created_at < (現在時刻 - 24時間)
- **削除頻度**: 1日1回（毎日深夜2時実行）

#### 3.4.3 削除処理の実装
- **Cron Job**: 定期実行による自動削除
- **バッチ処理**: 大量データの効率的な削除
- **トランザクション**: データ整合性の保証
- **ログ記録**: 削除処理の実行ログ

#### 3.4.4 容量監視
- **テーブルサイズ監視**: 各テーブルの容量監視
- **削除効果測定**: 削除前後の容量比較
- **アラート設定**: 容量超過時の通知
- **パフォーマンス影響**: 削除処理の負荷監視

## 4. フロントエンド実装設計

### 4.1 チャット画面UI設計

#### 4.1.1 全体UI構成
```
┌─────────────────────────────────────────────────────────┐
│ ナビゲーションバー (Navigation Bar)                      │
│ [←] 掲示板に戻る  [相手のニックネーム]  [通話] [設定]      │
├─────────────────────────────────────────────────────────┤
│ チャットエリア (ScrollView + LazyVStack)                │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ マッチ成立メッセージ (システムメッセージ)              │ │
│ │ "○○さんとマッチしました！20分間チャットできます"      │ │
│ │ 残り時間: 19:45 (カウントダウンタイマー)              │ │
│ └─────────────────────────────────────────────────────┘ │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ 相手メッセージ (左寄せ)                              │ │
│ │ [アバター] こんにちは！                              │ │
│ │ 既読 14:30                                          │ │
│ └─────────────────────────────────────────────────────┘ │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ 自分のメッセージ (右寄せ)                            │ │
│ │ よろしくお願いします！ [アバター]                    │ │
│ │ 送信済み 14:31                                      │ │
│ └─────────────────────────────────────────────────────┘ │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ 画像メッセージ (プレビュー)                          │ │
│ │ [画像プレビュー] 写真を送信しました                  │ │
│ │ 送信済み 14:32                                      │ │
│ └─────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ 広告バナー (課金状態に応じて表示/非表示)                 │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ [広告バナー] プレミアムで広告非表示に！              │ │
│ └─────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│ メッセージ入力エリア (MessageInputView)                 │
│ ┌─────────────────────────────────────────────────────┐ │
│ │ [📷] [メッセージ入力フィールド] [送信]                │ │
│ └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

#### 4.1.2 掲示板機能との連携設計

##### 掲示板からの遷移フロー
```
掲示板画面 (BulletinBoardView)
├── マッチング申請ボタン
├── マッチ成立通知 (Toast/Alert)
└── チャット画面への遷移
    ├── マッチ成立時: 自動遷移
    ├── 既存チャット: タップで遷移
    └── 20分経過後: チャット非表示
```

##### チャット一覧表示ロジック
- **アクティブチャット表示**: 20分以内のチャットのみ表示
- **横スクロールカード**: 相手のプロフィール画像 + ニックネーム + 残り時間
- **タップ遷移**: カードタップでチャット画面に遷移
- **リアルタイム更新**: 残り時間のカウントダウン表示

#### 4.1.3 20分制限機能のUI表示

##### カウントダウンタイマー表示
- **ヘッダー表示**: 残り時間を分:秒形式で表示
- **色分け表示**: 残り時間に応じた色変化（緑→黄→赤）
- **緊急度アイコン**: 5分未満で警告アイコン表示
- **時間切れ表示**: 20分経過後はチャット非表示

### 4.1.11 データベースからUI表示への変換ロジック

#### 4.1.11.1 データ取得から表示までの流れ

##### 1. 初期データ読み込み
アプリ起動時、以下の順序でデータを取得・接続を確立します：

**アプリ起動時（WebSocket接続確立）**:
1. **WebSocket接続開始**: アプリ起動と同時にWebSocket接続を確立
2. **認証**: JWTトークンを使用してWebSocket接続を認証
3. **接続状態監視**: 接続状態を監視し、切断時は自動再接続

**掲示板画面表示時**:
1. **チャットルーム一覧取得**: `chat_rooms`テーブルから現在のユーザーが参加しているルームを取得
2. **20分制限フィルタリング**: `created_at`フィールドから現在時刻を引いて20分以内のルームのみを抽出
3. **参加者情報取得**: `room_participants`テーブルから相手のユーザー情報を取得
4. **最新メッセージ取得**: `messages`テーブルから各ルームの最新メッセージを取得
5. **UI表示用データ変換**: 取得したデータをSwiftUIの`@Published`プロパティに格納

##### 2. チャット画面表示時のデータ処理
ユーザーがチャット画面を開いた際の処理：

1. **ルーム選択**: 選択されたチャットルームのIDを基に詳細データを取得
2. **メッセージ履歴取得**: 該当ルームの全メッセージを時系列順で取得
3. **添付ファイル情報取得**: `message_attachments`テーブルから画像データのメタデータを取得
4. **既読状態更新**: メッセージの既読状態を更新
5. **ルーム参加**: 既存のWebSocket接続でチャットルームに参加

##### 3. メッセージ表示の変換ロジック

**テキストメッセージの表示**:
- `messages.content`フィールドのテキストを`MessageBubbleView`に渡す
- `messages.sender_id`と現在のユーザーIDを比較して左右配置を決定
- `messages.created_at`を`HH:mm`形式にフォーマットして時間表示
- `messages.is_read`フラグで既読状態のチェックマーク表示
 - 制約: 1メッセージあたり最大500文字

**画像メッセージの表示**:
- 添付はREST APIから取得: `GET /messages/:messageId/attachments/:attachmentId`（JWT必須）
- `message_attachments`テーブルから`file_data`（BYTEA型）を取得
- バイナリデータをUIImageに変換してプレビュー表示
- `file_size`と`mime_type`でファイル情報を表示
- タップ時にフルスクリーン表示用のURLを生成

##### 4. 20分制限の表示制御

**時間計算ロジック**:
```swift
// 残り時間の計算
let timeLimit: TimeInterval = 20 * 60 // 20分を秒に変換
let elapsedTime = Date().timeIntervalSince(chatRoom.createdAt)
let remainingTime = max(0, timeLimit - elapsedTime)

// 表示制御
if remainingTime > 0 {
    // チャット表示可能
    showChatInterface()
} else {
    // 時間切れ表示
    showTimeExpiredView()
}
```

**色分け表示ロジック**:
- 残り時間 > 10分: 緑色（安全）
- 残り時間 5-10分: オレンジ色（注意）
- 残り時間 < 5分: 赤色（緊急）

##### 5. 既読機能の表示制御

**既読状態の判定**:
1. メッセージ送信時に`is_read = false`でDBに保存
2. 相手がメッセージを開いた際にWebSocketで既読イベントを受信
3. 該当メッセージの`is_read`フラグを`true`に更新
4. UI上でチェックマークの色と「既読」テキストを表示

**既読表示の条件**:
- 自分のメッセージのみ既読状態を表示
- 相手のメッセージには既読表示なし
- 送信済み（未読）: グレーの空丸チェックマーク
- 既読: 青い塗りつぶしチェックマーク + 「既読」テキスト

##### 6. 広告表示の制御ロジック

**表示条件の判定**:
1. `user_subscriptions`テーブルでユーザーの課金状態を確認
2. RevenueCatのエンタイトルメント状態を取得
3. 無料ユーザーのみ広告バナーを表示
4. `ad_banners`テーブルからアクティブな広告を取得

**広告データの変換**:
- `ad_banners.image_url`から画像を非同期読み込み
- `expires_at`で広告の有効期限をチェック
- タップ時に`click_url`に遷移

##### 7. リアルタイム更新の処理

**WebSocket接続のライフサイクル**:
1. **アプリ起動時**: WebSocket接続を確立し、認証を完了
2. **チャット画面表示時**: 既存接続でチャットルームに参加
3. **メッセージ送受信**: リアルタイムでメッセージを送受信
4. **アプリ終了時**: WebSocket接続を適切に切断

**WebSocketメッセージ受信時**:
1. 受信したメッセージデータを`messages`テーブルに保存
2. ローカルの`@Published`配列に追加
3. UIが自動的に更新（SwiftUIのリアクティブ更新）
4. 最新メッセージに自動スクロール

**接続状態の管理**:
- **接続中**: 通常のメッセージ送受信
- **切断時**: ローカルキャッシュから表示継続、自動再接続を試行
- **再接続時**: 未読メッセージを同期、チャットルームに再参加
- **バックグラウンド時**: 接続を維持しつつ、APNsでプッシュ通知

##### 8. データの永続化とキャッシュ

**ローカルキャッシュ**:
- SwiftDataを使用してメッセージをローカル保存
- オフライン時も過去のメッセージを表示可能
- ネットワーク復旧時にサーバーと同期

**メモリ管理**:
- 古いメッセージは必要に応じてメモリから解放
- 画像は必要時のみメモリに読み込み
- 24時間経過したデータは自動削除

#### 4.1.11.2 パフォーマンス最適化

**データ取得の最適化**:
- ページネーションでメッセージを分割取得
- インデックスを活用した高速クエリ
- 不要なデータの取得を避ける

**UI更新の最適化**:
- `LazyVStack`でメッセージの遅延読み込み
- 画像の非同期読み込みとキャッシュ
- 差分更新でUIの再描画を最小化

**メモリ使用量の制御**:
- 画像の適切なリサイズと圧縮
- 古いメッセージの段階的な解放
- バックグラウンド時のメモリ節約

#### 4.1.1 Swift 6.1 Concurrency ベース設計
```
Chat Module (Swift 6.1 + SwiftUI)
├── Views (SwiftUI)
│   ├── ChatView (メイン画面)
│   ├── MessageBubbleView (メッセージ表示)
│   ├── MessageInputView (入力フィールド)
│   └── BannerAdView (広告表示)
├── ViewModels (@MainActor)
│   ├── ChatViewModel (チャット状態管理)
│   └── MessageViewModel (メッセージ管理)
├── Services (Actor分離)
│   ├── WebSocketService (Actor)
│   ├── ChatService (Actor) - 20分制限管理
│   ├── AdService (@MainActor) - 広告管理
│   └── RevenueCatService (@MainActor) - 課金管理
├── Models (SwiftData)
│   ├── User (@Model) - nickname, gender, age, prefecture
│   ├── ChatRoom (@Model)
│   ├── RoomParticipant (@Model)
│   ├── Message (@Model)
│   ├── MessageAttachment (@Model)
│   └── AdBanner (@Model)
└── Utils
    ├── WebSocketManager (Actor)
    └── NetworkManager (Actor)
```

#### 4.1.2 Swift 6.1 Concurrency活用
- **Actor分離**: データ競合を防ぐ安全な並行処理
- **@MainActor**: UI更新のメインスレッド保証
- **async/await**: 非同期処理の簡潔な記述
- **TaskGroup**: 並列処理の効率的な管理

### 4.2 主要コンポーネント設計

#### 4.2.1 ChatView (メイン画面)
- **SwiftUI**: 宣言的UI、状態管理
- **TabView**: 横スクロールチャット切り替え
- **ScrollViewReader**: 自動スクロール
- **refreshable**: プルリフレッシュ対応
- **onChange**: リアクティブな状態更新
- **20分制限表示**: expires_atによる表示制御

#### 4.2.2 WebSocketService (Actor)
- **URLSessionWebSocketTask**: WebSocket通信
- **自動再接続**: 指数バックオフアルゴリズム
- **接続状態管理**: リアルタイム状態監視
- **メッセージ送受信**: 非同期メッセージ処理
- **エラーハンドリング**: 接続エラーの適切な処理


#### 4.2.3 ChatService (Actor)
- **20分制限管理**: created_atによる表示制御
- **チャット状態管理**: アクティブ/非表示状態の管理
- **切迫感演出**: 残り時間の表示・通知
- **タイマー計算**: リアルタイム残り時間計算（1秒間隔）

#### 4.2.4 RevenueCatService (@MainActor)
- **RevenueCat SDK**: 課金状態管理
- **エンタイトルメント**: 機能制御
- **広告表示制御**: 課金状態に応じた表示
- **購入フロー**: サブスクリプション管理

### 4.3 データ管理設計

#### 4.3.1 SwiftData活用
- **@Model**: データモデル定義
- **ModelContainer**: データ永続化
- **@Query**: リアクティブなデータ取得
- **ローカルキャッシュ**: オフライン対応

#### 4.3.2 状態管理
- **@StateObject**: ViewModel管理
- **@Published**: リアクティブな状態更新
- **@Binding**: 双方向データバインディング
- **@EnvironmentObject**: グローバル状態管理

### 4.4 バックエンド実装設計

#### 4.4.1 Nest.js 10 アーキテクチャ
```
Backend (Nest.js 10 + Socket.io 4.7)
├── Controllers
│   ├── ChatController (REST API)
│   ├── AdController (広告管理)
│   └── SubscriptionController (課金管理)
├── Services
│   ├── ChatService (チャット処理)
│   ├── WebSocketService (リアルタイム通信)
│   ├── AdService (広告管理)
│   └── RevenueCatService (課金管理)
├── Gateways
│   ├── ChatGateway (WebSocket)
│   └── AdGateway (広告配信)
├── Entities (Prisma)
│   ├── User - nickname, gender, age, prefecture
│   ├── ChatRoom
│   ├── RoomParticipant
│   ├── Message
│   ├── MessageAttachment
│   └── AdBanner
└── Utils
    ├── JwtAuthGuard
    └── RateLimitGuard
```

#### 4.4.2 Socket.io 4.7 活用
- **リアルタイム通信**: 双方向WebSocket通信
- **ルーム管理**: チャットルーム別の接続管理
- **イベント駆動**: メッセージ、既読イベント
- **自動再接続**: クライアント側の自動再接続
- **認証統合**: JWT認証との統合


### 4.4 広告・課金統合設計

#### 4.4.1 広告表示制御
- **RevenueCat連携**: 課金状態の確認
- **条件付き表示**: 無料ユーザーのみ広告表示
- **動的広告**: ユーザー属性に応じた広告選択
- **インプレッション追跡**: 広告表示回数の記録

#### 4.4.2 課金状態管理
- **エンタイトルメント**: 機能制御の一元管理
- **Webhook連携**: サーバー側での課金状態同期
- **オフライン対応**: ローカルキャッシュによる状態保持
- **自動更新**: サブスクリプション状態の自動更新

## 5. 認証・認可設計

### 5.1 JWT認証
- **トークン管理**: アクセストークン + リフレッシュトークン
- **有効期限**: アクセストークン1時間、リフレッシュトークン30日
- **WebSocket認証**: 接続時のJWT検証
- **自動更新**: トークン期限切れ時の自動更新

### 5.2 アクセス制御
- **ルームアクセス**: 参加権限のあるルームのみアクセス
- **メッセージ検証**: 送信者の身元確認
- **デバイス制限**: 1ユーザーあたり最大2デバイス
- **IP制限**: 同一IPあたり最大2デバイス
- **レート制限**: 1デバイスあたり100リクエスト/分

## 6. パフォーマンス設計

### 6.1 最適化戦略

#### 6.1.1 データベース最適化
- **インデックス最適化**: 検索パフォーマンス向上
- **接続プール**: 効率的な接続管理
- **クエリ最適化**: Prismaクエリの最適化
- **パーティショニング**: 時系列データの分割

#### 6.1.2 リアルタイム通信最適化
- **WebSocket接続管理**: 効率的な接続管理
- **メッセージバッファリング**: 大量メッセージの処理
- **負荷分散**: 複数サーバーでの負荷分散
- **キャッシュ戦略**: 頻繁にアクセスされるデータのキャッシュ

### 6.2 スケーラビリティ設計

#### 6.2.1 水平スケーリング
- **マイクロサービス**: 独立したサービス構成
- **ロードバランサー**: トラフィック分散
- **データベース分散**: 読み取り専用レプリカ
- **CDN活用**: 静的コンテンツの配信最適化

#### 6.2.2 垂直スケーリング
- **リソース監視**: CPU、メモリ使用率監視
- **自動スケーリング**: 負荷に応じたリソース調整
- **パフォーマンステスト**: 負荷テストの実施
- **ボトルネック特定**: パフォーマンス問題の特定

## 7. 監視・運用設計

### 7.1 監視項目

#### 7.1.1 システム監視
- **接続数**: アクティブWebSocket接続数
- **メッセージ量**: 1分間のメッセージ送信数
- **エラー率**: 接続エラー・送信エラー率
- **レスポンス時間**: メッセージ送信から受信までの時間
- **データベース容量**: 各テーブルのサイズ監視
- **削除処理**: 自動削除処理の実行状況

#### 7.1.2 ビジネス監視
- **ユーザー数**: アクティブユーザー数
- **チャット数**: 1日あたりのチャット数
- **広告表示数**: 広告インプレッション数
- **課金率**: 有料ユーザー率

### 7.2 アラート設定

#### 7.2.1 システムアラート
- **接続数超過**: 同時接続数が100を超えた場合
- **エラー率上昇**: エラー率が5%を超えた場合
- **メッセージ遅延**: 平均レスポンス時間が1秒を超えた場合
- **データベース負荷**: CPU使用率が80%を超えた場合
- **容量超過**: データベース容量が80%を超えた場合
- **削除処理失敗**: 自動削除処理が失敗した場合

#### 7.2.2 ビジネスアラート
- **ユーザー減少**: アクティブユーザー数が前日比20%減少
- **広告収益低下**: 広告収益が前日比30%減少
- **課金率低下**: 課金率が前月比10%減少
- **異常なアクセス**: 不正なアクセスパターンの検出



*この設計書は、2025年9月14日時点の最新技術を活用したマッチングアプリの20分制限付きチャット機能の実装指針を提供します。Swift 6.1 Concurrency、Nest.js 10、Socket.io 4.7、PostgreSQL 17、RevenueCatを組み合わせた高性能で安全なシステムの構築を目指します。*
